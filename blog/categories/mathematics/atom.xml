<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Mathematics | thefourtheye's weblog]]></title>
  <link href="http://thefourtheye.in/blog/categories/mathematics/atom.xml" rel="self"/>
  <link href="http://thefourtheye.in/"/>
  <updated>2018-05-27T11:53:52+05:30</updated>
  <id>http://thefourtheye.in/</id>
  <author>
    <name><![CDATA[Sakthipriyan Vairamani (thefourtheye)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Project Euler - 14 - Longest Collatz Sequence - Memoization]]></title>
    <link href="http://thefourtheye.in/2013/06/15/Project-Euler-14-Longest-Collatz-sequence-memoization/"/>
    <updated>2013-06-15T18:56:00+05:30</updated>
    <id>http://thefourtheye.in/2013/06/15/Project-Euler-14-Longest-Collatz-sequence-memoization</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on">This post is about the <a href="http://projecteuler.net/problem=14">Project Euler - 14 - Longest Collatz sequence</a> problem. This is one of the perfect examples of memoization technique. This is the actual problem.<br /><br /><pre>The following iterative sequence is defined for the set of positive integers:<br /><br />n → n/2 (n is even)<br />n → 3n + 1 (n is odd)<br /><br />Using the rule above and starting with 13, we generate the following sequence:<br />13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1<br /><br />It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.<br /><br />Which starting number, under one million, produces the longest chain?<br /><br />NOTE: Once the chain starts the terms are allowed to go above one million.<br /></pre><br /><h2>Simple Solution</h2><br />The problem statement looks pretty simple and a brute force will work just fine. This code runs in 20 seconds.<br /><br /><pre class="prettyprint"><br />def Series(N):<br />    Counter = 1<br />    while N != 1:<br />        N = N/2 if N % 2 == 0 else 3*N+1<br />        Counter += 1<br />    return Counter<br /><br />Max, Element = 0, 0<br />for x in xrange (1, 1000000):<br />    series = Series(x)<br />    if (Max &lt; series):<br />        Max = series<br />        Element = x<br /><br />print Max, Element<br /><br /></pre><br /><br />As I had to wait for 20 seconds to get the solution, I was thinking about improving the performance. Then I found this. From the problem statement, <code>13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</code>, starting with any number, if it becomes 13 at any point of time, it has to take the same route and if it becomes 13 it will take 10 steps to become 1. So I wanted to store this information first time itself, so that I don't have to recalculate. This is called <code>Memoization</code>. Quoting from wikipedia<br /><br /><blockquote>In computing, memoization is an optimization technique used primarily to speed up computer programs by having function calls avoid repeating the calculation of results for previously processed inputs</blockquote><br /><h2>Optimized (Memoized) Solution</h2><br />To optimize it, I just had to change the Series function alone. I stored the computed values in a dictionary and if the current number in the sequence happens to be in the dictionary, I ll just return the value corresponding to it. This program responded with the result in 2 seconds. That is <b>10 times faster</b> than the first version.<br /><br /><pre class="prettyprint"><br />Dict = {}<br /><br />def Series(N):<br />    Counter = 1   #It is 1, because we are counting the initial N<br />    Original = N<br />    while N != 1:<br />        N = N/2 if N % 2 == 0 else 3*N+1<br />        if N in Dict:                    # Check if the length has been computed for this number already<br />            Counter += Dict[N]           # Add it to the current length counter<br />            Dict [Original] = Counter    # Store the computed value for future look back<br />            return Counter<br />        Counter += 1<br />    Dict [Original] = Counter            # Store the computed value for future look back<br />    return Counter<br /><br /></pre><br /><br /><br /><br /></div></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler - Problem 5 - Smallest Multiple]]></title>
    <link href="http://thefourtheye.in/2013/06/15/Project-Euler-Problem-5-Smallest-multiple/"/>
    <updated>2013-06-15T13:05:00+05:30</updated>
    <id>http://thefourtheye.in/2013/06/15/Project-Euler-Problem-5-Smallest-multiple</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on">Today I came across this interesting problem. <a href="http://projecteuler.net/problem=5">Project Euler's Problem 5 - Smallest Multiple</a>. <br /><br /><pre>2520 is the smallest number that can be divided by each of the numbers from 1 to 10 without any remainder.<br /><br />What is the smallest positive number that is evenly divisible by all of the numbers from 1 to 20?<br /></pre><br />Definitely 20! (factorial of 20) is one, which will be evenly divisible by all of the numbers from 1 to 20. But the problem is to find the <b>smallest</b> positive number. So, I thought, it would be the number which is the product of all the prime numbers within 20. I calculated <code>2 * 3 * 5 * 7 * 11 * 13 * 17 * 19 = 9699690</code>, which is wrong, since a number divisible by 2 might not be divisible by 4 and the same applies for other prime numbers and their multiples. After little thinking, I couldn’t get a way to find the solution. So I applied brute force and my solution got accepted.<br /><br /><h2>Brute Force Solution</h2><br /><pre class="prettyprint">i = 21<br />while True:<br />    flag = True<br />    for X in xrange(1, 21):<br />        if (i % X != 0):<br />            flag = False<br />            break<br />    if flag:<br />        print i<br />        break<br />    i += 1<br /></pre><br />But the problem with this solution is, the time taken to produce the result. It took 162 seconds or 2 minutes and 32 seconds. I wondered if I can improve my solution to produce solution in a reasonable amount of time. I couldn’t, so I googled and got this <a href="http://stackoverflow.com/a/13765976/1903116">page</a>. Its high school maths. <br /><br /><h2>Optimized Solution</h2><br /><h2>LCM</h2>Least Common Divisor (LCM) of numbers A and B, is a number which is the least number divisible by both A &amp; B. Moreover LCM (A, B, C) = LCM (LCM (A, B), C) and so on.<br /><br /><h2>Relation between LCM and GCD</h2><code>LCM(A,B) = (A * B)/GCD(A*B)</code><br /><br /><h2>Recursive Euclid's algorithm for GCD</h2><h6>Base Condition</h6><code>GCD(A, 0) = A</code><br /><h6>Recurrence Relation</h6><code>GCD(A, B) = GCD (B, A mod B)</code><br /><br />So I modified my code like this and it produced the solution within 1 second.<br /><br /><pre class="prettyprint">def GCD(M, N):<br />    while (N != 0):<br />        M, N = N, M % N<br />    return M<br /><br />LCM = 1<br />for X in xrange(1, 21):<br />    LCM = (X * LCM)/GCD(X, LCM)<br />print LCM<br /></pre><br /><br /></div></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prime Numbers and Basic Primality Tests - SPOJ - Prime1]]></title>
    <link href="http://thefourtheye.in/2012/10/09/prime-numbers-and-basic-primality-tests/"/>
    <updated>2012-10-09T16:40:00+05:30</updated>
    <id>http://thefourtheye.in/2012/10/09/prime-numbers-and-basic-primality-tests</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on"><b>Prime numbers</b> are the numbers which get divided properly (leaving remainder as 0) only by 1 and the same number.<br /><br />The same way, numbers which get divided by 1, the same number and other numbers are called <b>composite numbers</b>.<br /><br />Current state of the art security infrastructures rely on security schemes such as RSA and DSA. They both, in turn, rely heavily on Prime numbers. So prime numbers are so important in the digital world's security. Lets see few of the algorithms to determine whether the given number is a Prime number or not.<br /><br /><h3 style="text-align: left;">Basic Tests for Primality</h3><div>Lets say, we want to find whether the numbers 101 and 100 are prime numbers are not.</div><h4 style="text-align: left;">Approach 1</h4><div><br /></div><div>This is the very basic approach and very easy to implement.</div><div><br /></div><div style="text-align: left;"><ul style="text-align: left;"><li>Read the number n</li><li>Loop with i from 2 till n/2 (if it doesn't divide properly, round off is needed)</li><li>if i divides n with out leaving any remainder (remainder is 0)&nbsp;then return false</li><li>End Loop</li><li>return true</li></ul><div><br /></div><div>The idea here is to check whether each and every number from 2 till half of that number [2, n/2] divides the number or not. If any of them divides the number without leaving any remainder, we can declare that the number is NOT a prime number. If no number in that range divides properly, the number is called a Prime number. We check only till n/2, because 2 * n/2 would be n, there would be no number greater than n/2 would divide n properly. In the worst case, It needs n/2 iterations to confirm whether the number is prime or not. In our case, for 101,&nbsp;it is 50.</div><div><br /></div><div><h4>Approach 2</h4></div><div><br /></div><div>The simplicity of this algorithm would tempt us to use this always. Lets see, if we can improve this. If we observe closely, if the number n is odd, we don't even have to try any of the even numbers. This would reduce the number of iterations needed by half.</div><div><br /></div><div><ul><li>Read the number n</li><li>if n is even return false</li><li>Loop with i from 3 till n/2, increment i by 2</li><li>if i divides n with out leaving any remainder (remainder is 0)&nbsp;then return false</li><li>End Loop</li><li>return true</li></ul><div><br /></div></div><div>As we can clearly see, if n is even it can not be a prime number, since if a number is even it is divisible by 2. So we check only the odd numbers starting from 3 till n/2 and we are skipping all the even number &nbsp;by incrementing the loop's index variable by 2 every time. So the loop would be run for the values 3,5,7,9, 11... Now if we look at the performance of this approach, we just need n/4 iterations to find whether the number is a prime number or not. In our case, for 101, it is 25.</div><div><br /></div><h4 style="text-align: left;">Approach 3</h4><div><br /></div><div>Lets see, if we can reduce it further from n/4. Lets write down the combinations which would yield 100. {2, 50}, {4, 25}, {5, 20} and {10, 10}. Lets try 256. {2, 128}, {4, 64}, {8, 32}, {16, 16}. In both the cases, atleast one of the numbers is always lesser than equal to the square root of the actual number. (I, honestly, don't know how to prove this, but this observation works always). So, instead of looping till n/2 we are going to limit the loop at square root of the number. Combining the observation we made in approach 2, presenting approach 3.</div><div><br /></div><div><ul><li>Read the number n</li><li>if n is even return false</li><li>Loop with i from 3 till sqrt (n), increment i by 2</li><li>if i divides n with out leaving any remainder (remainder is 0)&nbsp;then return false</li><li>End Loop</li><li>return true</li></ul><div><br /></div><div>In our case, we see a tremendous hike in performance,&nbsp;for the value 101,&nbsp;in the worst case we might have to do only 4 checks.</div></div><div><br /></div><div><h4>Approach 4</h4></div><div><br /></div><div>We have already had good performance with approach 3. Lets see if we still can improve it. Lets list the four values with which we may need to divide 101 to determine whether it is prime or not. The values are {2, 3, 5, 7, 9}. We have 2 as well here, since we check whether the input is even or not and 11 is not included because sqrt (101) would be rounded off to 10. The odd item in the list is 9, since we are checking against all the odd number between 2 and sqrt(n). We all know that, any given composite (non-prime) number can be expressed in terms of its prime factors. So we can try and divide the number only with the prime numbers within the range [2, sqrt(n)]. <b>Note:</b> This approach works only when we have a predetermined list of prime numbers. If we don't have that its better to stick to approach 3 or have a look at approach 5 below.</div><div><br /></div><div><h4>Approach 5</h4></div><div><br /></div><div>Lets observe the list the prime numbers a bit.</div><div><span style="font-family: inherit;"><br /></span></div><div><span style="font-family: inherit;">{<span style="background-color: white; line-height: 19.200000762939453px;">2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101...}</span></span></div><div><span style="font-family: inherit;"><span style="background-color: white; line-height: 19.200000762939453px;"><br /></span></span></div><div><span style="font-family: inherit;"><span style="background-color: white; line-height: 19.200000762939453px;">Lets rewrite them like this</span></span></div><div><span style="font-family: inherit;"><span style="background-color: white; line-height: 19.200000762939453px;"><br /></span></span></div><div>{<span style="background-color: white; line-height: 19.200000762939453px;">2, 3, 6*1-1,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*1+1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*2-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*2+1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*3-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*3+1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*4-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*5-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*5+1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*6+1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*7-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*7+1,</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*8-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*9-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*10-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*10+1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*11+1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*12-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*12+1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*13-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*14-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*15-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*16+1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*17-1</span><span style="background-color: white; line-height: 19.200000762939453px;">...}</span></div><div><span style="background-color: white; line-height: 19.200000762939453px;"><br /></span></div><div><span style="background-color: white; line-height: 19.200000762939453px;">Basically, the prime numbers are of the form <span style="font-family: inherit;">(6*x)</span></span><span style="background-color: white; color: #222222; line-height: 16px;"><span style="font-family: inherit;">±1 (though few of them may not be prime numbers). This reduces the possible values to be looked at, to a greater extent.&nbsp;</span></span></div><div><span style="background-color: white; color: #222222; line-height: 16px;"><span style="font-family: inherit;"><br /></span></span></div><div><ul><li>Read the number n</li><li>if n is even return false</li><li>if 3 divides n properly return false</li><li>Loop with i from 1 till&nbsp;(6 * i) -1 &gt;&nbsp;sqrt&nbsp;(n), increment i by 1 every time</li><li>if&nbsp;(6 * i) -1 or&nbsp;(6 * i) + 1&nbsp;divides n with out leaving any remainder (remainder is 0)&nbsp;then return false</li><li>End Loop</li><li>return true</li></ul><div><br /></div><div>This method would be the fastest of all the methods discussed, I believe.</div></div><div><br /></div><div>Based on the ideas discussed above, I managed to solved the SPOJ's PRIME1 problem. The problem description can be found here&nbsp;<a href="http://www.spoj.pl/problems/PRIME1/" target="_blank">http://www.spoj.pl/problems/PRIME1/</a></div><div><br /></div><div><b>Spoiler alert:</b> This&nbsp;<a href="http://ideone.com/4n9kB">http://ideone.com/4n9kB</a>&nbsp;has my solution to the above mentioned PRIME1 problem.</div></div></div><script type="text/javascript" src="http://ideone.com/api/embed.js/link/4n9kB"></script></div>
]]></content>
  </entry>
  
</feed>
