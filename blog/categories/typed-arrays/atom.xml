<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Typed Arrays | thefourtheye's weblog]]></title>
  <link href="http://thefourtheye.in/blog/categories/typed-arrays/atom.xml" rel="self"/>
  <link href="http://thefourtheye.in/"/>
  <updated>2017-05-26T22:31:50+05:30</updated>
  <id>http://thefourtheye.in/</id>
  <author>
    <name><![CDATA[Sakthipriyan Vairamani (thefourtheye)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[TypedArrays and Canonical Numeric Index Strings]]></title>
    <link href="http://thefourtheye.in/2017/05/25/typedarrays-and-canonical-numeric-index-strings/"/>
    <updated>2017-05-25T07:44:01+05:30</updated>
    <id>http://thefourtheye.in/2017/05/25/typedarrays-and-canonical-numeric-index-strings</id>
    <content type="html"><![CDATA[<p>This week, I saw a Tweet by Benedikt Meurer which was kind of a quiz.</p>

<center>
  <blockquote class="twitter-tweet" data-lang="en">
    <p lang="en" dir="ltr">Fun to see <a href="https://twitter.com/jaffathecake">@jaffathecake</a> and <a href="https://twitter.com/aerotwist">@aerotwist</a> presenting our weird JavaScript question. üôÉ Did you know the answer? üòé <a href="https://t.co/nOqtExHsvS">https://t.co/nOqtExHsvS</a> <a href="https://t.co/KVFmyAg3q5">pic.twitter.com/KVFmyAg3q5</a>
    </p>&mdash; Benedikt Meurer (@bmeurer) <a href="https://twitter.com/bmeurer/status/866339039200325632">May 21, 2017</a>
  </blockquote>
  <script async="" src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
</center>

<p>At the first look, I thought all of them would be the properties of the object and so all are correct answers. This comes from my understanding of the <code>Array</code> objects. As per the specification‚Äôs <a href="http://www.ecma-international.org/ecma-262/7.0/#sec-array-exotic-objects">9.4.2 Array Exotic Objects</a> section,</p>

<blockquote>
  <p>A String property name P is an array index if and only if ToString(ToUint32(P)) is equal to P and ToUint32(P) is not equal to 2<sup>32</sup>-1.</p>
</blockquote>

<p>Any String property name which when converted to an unsigned 32 bit integer and stringified again should be equal to the original String property name, to be qualified as a valid array index. Otherwise it will be treated as a normal property of the array object.</p>

<p>But this is not applicable to <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/TypedArray">TypedArrays</a>. To TypedArrays the array indices in string format, should be <i>canonical string numeric indices</i>. In ECMAScript 6 specification, value of a property retrieval from a typed array is defined like this</p>

<blockquote>
  <p>When the [[Get]] internal method of an Integer Indexed exotic object (Typed Arrays) <i>O</i> is called with property key <i>P</i>, as per the section <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-integer-indexed-exotic-objects-get-p-receiver">9.4.5.4 [[Get]] (P, Receiver)</a>  the following steps are taken:</p>

  <ol>
    <li>Assert: IsPropertyKey(<i>P</i>) is <b>true</b>.</li>
    <li>If Type(<i>P</i>) is String and if SameValue(<i>O</i>, <i>Receiver</i>) is <b>true</b>, then<br />
a. Let <i>numericIndex</i> be CanonicalNumericIndexString (<i>P</i>).<br />
b. Assert: <i>numericIndex</i> is not an abrupt completion.<br />
 c. If <i>numericIndex</i> is not <b>undefined</b>, then<br />
    i. Return IntegerIndexedElementGet (<i>O</i>, <i>numericIndex</i>).</li>
    <li>Return the result of calling the default ordinary object [[Get]] internal method (9.1.8) on <i>O</i> passing <i>P</i> and <i>Receiver</i> as arguments.</li>
  </ol>
</blockquote>

<p>As we see here, if the property being retrieved is a String, it is first converted to its canonical numeric index string format. It is done as per the section <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-canonicalnumericindexstring">7.1.16 CanonicalNumericIndexString(argument)</a></p>

<blockquote>
  <ol>
    <li>Assert: Type(<i>argument</i>) is String.</li>
    <li>If <i>argument</i> is <b>‚Äú-0‚Äù</b>, return ‚àí0.</li>
    <li>Let <i>n</i> be ToNumber(<i>argument</i>).</li>
    <li>If SameValue(ToString(<i>n</i>), <i>argument</i>) is <b>false</b>, return <b>undefined</b>.</li>
    <li>Return <i>n</i>.</li>
  </ol>
</blockquote>

<p>This basically converts the string to a number object and then compares the stringified version of that number with the original string. If they are equal, then it is a canonical numeric index and the number is returned, otherwise <code>undefined</code> will be returned. For example, <code>'3.14'</code> will be converted to numeric <code>3.14</code> and then converted to string again, which will be <code>'3.14'</code> which is the same as the original string. So the number <code>3.14</code> it will be considered as an index of the typed array.</p>

<p>In the question we see above, the strings <code>'.9'</code> and <code>'1.0'</code> become <code>'0.9'</code> and <code>1</code> respectively and <code>'1.1'</code> and <code>'1.2'</code> will become the same. We can confirm that like this</p>

<pre><code class="language-js">['.9', '0.9', '1.0', '1.', '1.1', '1.2'].forEach(i =&gt; console.log(Number(i).toString()));
// will print the following
0.9
0.9
1
1
1.1
1.2
</code></pre>

<p>As the strings <code>'1.1'</code> and <code>'1.2'</code> are already in the canonical numeric index string format, they are considered as the array indices and the <code>'0.9'</code> and <code>'1.0'</code> become property names. As per the <a href="http://www.ecma-international.org/ecma-262/6.0/#sec-integerindexedelementget">9.4.5.8 IntegerIndexedElementGet</a> section, the passed number should be an integer. So, <code>1.1</code> and <code>1.2</code> are also not valid array indices and they are ignored. That is why the answer to the question is, both <code>array['.9']</code> and <code>array['1.0']</code>, as only <code>'.9'</code> and <code>'1.0'</code> are treated as property names during retrieval.</p>

<p>To confirm this behaviour I wrote the following programs.</p>

<pre><code class="language-js">function TestIntegerIndexedObjects(obj) {
    console.log(Object.prototype.toString.call(obj));
    const items = ['.9', '1.0', '1.1', '1.2'];
    items.forEach((i, idx) =&gt; obj[i] = idx);
    console.log(obj);
    console.log(Object.getOwnPropertyNames(obj));
    console.log('\n');
}

TestIntegerIndexedObjects(new Int8Array(10));
TestIntegerIndexedObjects(new String("abcd"));
TestIntegerIndexedObjects([]);
</code></pre>
<p>will print the following</p>
<pre><code>[object Int8Array]
Int8Array [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, '.9': 0, '1.0': 1 ]
[ '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '.9', '1.0' ]


[object String]
[String: 'abcd']
[ '0', '1', '2', '3', 'length', '.9', '1.0', '1.1', '1.2' ]


[object Array]
[ '.9': 0, '1.0': 1, '1.1': 2, '1.2': 3 ]
[ 'length', '.9', '1.0', '1.1', '1.2' ]
</code></pre>

<h3 id="canonicalnumericindexstring">CanonicalNumericIndexString</h3>

<pre><code class="language-js">const assert = require('assert');

function CanonicalNumericIndexString(argument) {
    const NumericValue = +argument;                                          // The unary + operator converts to a number
    return NumericValue.toString() === argument ? NumericValue : undefined;
}

assert(CanonicalNumericIndexString('.9')  === undefined);
assert(CanonicalNumericIndexString('0.9') === 0.9);
assert(CanonicalNumericIndexString('1.0') === undefined);
assert(CanonicalNumericIndexString('1.')  === undefined);
assert(CanonicalNumericIndexString('1.1') === 1.1);
assert(CanonicalNumericIndexString('1.2') === 1.2);
</code></pre>
]]></content>
  </entry>
  
</feed>
