<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Dynamic Programming | thefourtheye's weblog]]></title>
  <link href="http://thefourtheye.in/blog/categories/dynamic-programming/atom.xml" rel="self"/>
  <link href="http://thefourtheye.in/"/>
  <updated>2018-03-21T19:50:45+05:30</updated>
  <id>http://thefourtheye.in/</id>
  <author>
    <name><![CDATA[Sakthipriyan Vairamani (thefourtheye)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Project Euler - 15 - Lattice Paths]]></title>
    <link href="http://thefourtheye.in/2013/06/15/project-euler-15-lattice-paths_15/"/>
    <updated>2013-06-15T21:22:00+05:30</updated>
    <id>http://thefourtheye.in/2013/06/15/project-euler-15-lattice-paths_15</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on">In this post we are dealing with <a href="http://projecteuler.net/problem=15">Project Euler - 15 - Lattice paths</a>. This is one of the simple dynamic programming problems. We have to find the number of paths to reach the bottom right from the top left, moving only downwards and right sidewards. It was not so easy for me to see the solution even for the sample data given. It would be easy when we look from the bottom-left. For the sample 2x2 grid, lets say the bottom-left (2, 2) point has 0 path and 1,2 and 2,1 have 1 path each. It is evident that number of paths to reach (2, 2) from all the points on the bottom most row (0, 2), (1, 2) and the right most column (2, 0), (2, 1), as we cannot move upwards and left sidewards. Now, (1, 1) has two paths to reach (2, 2), either through (1, 2) or (2, 1). So it has the value 2. Same way, (0, 1) and (1, 0) have 3 ways ( (0, 1) can take (1, 1) (which has 2 paths to (2, 2) ) and (0, 2) (which has 1 path to (2, 2) ). So, (0, 0) has 6 paths to (2, 2) either via (0, 1) or via (1, 0). Applied this idea as a dynamic programming program and it solved this problem.<br /><pre class="prettyprint">Total = 21<br /><br />Array = [[0]*Total for i in xrange(Total)]<br />for i in xrange(Total): Array[i][Total - 1], Array[Total - 1][i] = 1, 1   #Initializing bottom row and right column with 1<br /><br />def Rec(i, j):<br />    global Array<br />    if Array[i][j]: return Array[i][j]<br />    Rec(i+1, j)<br />    Rec(i, j+1)<br />    Array[i][j] = Array[i+1][j] + Array[i][j+1]<br /><br />Rec (0, 0)<br />print Array[0][0]<br /></pre></div></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler - 14 - Longest Collatz Sequence - Memoization]]></title>
    <link href="http://thefourtheye.in/2013/06/15/Project-Euler-14-Longest-Collatz-sequence-memoization/"/>
    <updated>2013-06-15T18:56:00+05:30</updated>
    <id>http://thefourtheye.in/2013/06/15/Project-Euler-14-Longest-Collatz-sequence-memoization</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on">This post is about the <a href="http://projecteuler.net/problem=14">Project Euler - 14 - Longest Collatz sequence</a> problem. This is one of the perfect examples of memoization technique. This is the actual problem.<br /><br /><pre>The following iterative sequence is defined for the set of positive integers:<br /><br />n → n/2 (n is even)<br />n → 3n + 1 (n is odd)<br /><br />Using the rule above and starting with 13, we generate the following sequence:<br />13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1<br /><br />It can be seen that this sequence (starting at 13 and finishing at 1) contains 10 terms. Although it has not been proved yet (Collatz Problem), it is thought that all starting numbers finish at 1.<br /><br />Which starting number, under one million, produces the longest chain?<br /><br />NOTE: Once the chain starts the terms are allowed to go above one million.<br /></pre><br /><h2>Simple Solution</h2><br />The problem statement looks pretty simple and a brute force will work just fine. This code runs in 20 seconds.<br /><br /><pre class="prettyprint"><br />def Series(N):<br />    Counter = 1<br />    while N != 1:<br />        N = N/2 if N % 2 == 0 else 3*N+1<br />        Counter += 1<br />    return Counter<br /><br />Max, Element = 0, 0<br />for x in xrange (1, 1000000):<br />    series = Series(x)<br />    if (Max &lt; series):<br />        Max = series<br />        Element = x<br /><br />print Max, Element<br /><br /></pre><br /><br />As I had to wait for 20 seconds to get the solution, I was thinking about improving the performance. Then I found this. From the problem statement, <code>13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1</code>, starting with any number, if it becomes 13 at any point of time, it has to take the same route and if it becomes 13 it will take 10 steps to become 1. So I wanted to store this information first time itself, so that I don't have to recalculate. This is called <code>Memoization</code>. Quoting from wikipedia<br /><br /><blockquote>In computing, memoization is an optimization technique used primarily to speed up computer programs by having function calls avoid repeating the calculation of results for previously processed inputs</blockquote><br /><h2>Optimized (Memoized) Solution</h2><br />To optimize it, I just had to change the Series function alone. I stored the computed values in a dictionary and if the current number in the sequence happens to be in the dictionary, I ll just return the value corresponding to it. This program responded with the result in 2 seconds. That is <b>10 times faster</b> than the first version.<br /><br /><pre class="prettyprint"><br />Dict = {}<br /><br />def Series(N):<br />    Counter = 1   #It is 1, because we are counting the initial N<br />    Original = N<br />    while N != 1:<br />        N = N/2 if N % 2 == 0 else 3*N+1<br />        if N in Dict:                    # Check if the length has been computed for this number already<br />            Counter += Dict[N]           # Add it to the current length counter<br />            Dict [Original] = Counter    # Store the computed value for future look back<br />            return Counter<br />        Counter += 1<br />    Dict [Original] = Counter            # Store the computed value for future look back<br />    return Counter<br /><br /></pre><br /><br /><br /><br /></div></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Project Euler - Problem 18, Problem 67 - Maximum Path Sum]]></title>
    <link href="http://thefourtheye.in/2013/06/12/project-euler-problem-18-problem-67/"/>
    <updated>2013-06-12T19:32:00+05:30</updated>
    <id>http://thefourtheye.in/2013/06/12/project-euler-problem-18-problem-67</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on">Its been quite sometime since I did some coding. Last Sunday, one of the best friends of mine (Clement Lloyd) asked me  if I can solve <a href="http://projecteuler.net/problem=18">Project Euler's Problem 18</a>. The problem name is Maximum path sum. Finally I got some time today and it is a simple Dynamic Programming Problem. The basic idea is to, keep on adding two adjacent elements of each row with the corresponding element in the previous row and keep the maximum of them. For example,<br /><br /><pre> 8<br />1 2<br /></pre><br />The maximum of 8+1 and 8+2 would be 10 and 10 would take 8's place. So we keep on doing this till we reach the top. For the sample input<br /><br /><pre>3<br />  7 4<br /> 2 4 6<br />8 5 9 3<br /></pre><br />After first Iteration,<br /><br /><pre>3<br />   7  4<br /> 10 13 15<br /></pre><br />After second Iteration,<br /><br /><pre>3<br />  20 19<br /></pre><br />After third  Iteration,<br /><br /><pre>23<br /></pre><br />Here is the solution which I used<br /><br /><pre class="prettyprint">import sys<br />sys.stdin  = open ("Input.txt")<br />sys.stdout = open ("Output.txt", "w")<br />Array = []<br />for line in sys.stdin: Array.append (map (int, line.split()))<br />Array.reverse()<br />temp_array = [0] * (len(Array) + 1)<br />for Row in Array:<br /> for i in xrange (len(Row)):<br />  temp_array[i] = Row[i] + max (temp_array[i], temp_array[i + 1])<br />print max (temp_array)<br /></pre><br />This solution will solve <a href="http://projecteuler.net/problem=67">Project Euler's Problem 67</a> as well.<br /><br /><br /><br /></div></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ - ACODE - AlphaCode]]></title>
    <link href="http://thefourtheye.in/2013/04/23/spoj-acode-alphacode/"/>
    <updated>2013-04-23T21:34:00+05:30</updated>
    <id>http://thefourtheye.in/2013/04/23/spoj-acode-alphacode</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on"><blockquote>Problem Description - <a href="http://www.spoj.com/problems/ACODE/">http://www.spoj.com/problems/ACODE/</a><br /><br />Approach :<br /><br />1) Initialize an Array of Size N with 0 and element 0 as 1<br />2) Loop through all the elements<br />3) If it is a valid single digit number, Copy the previous element's value to the current element (DP[i] = DP[i-1])<br />4) If it is a valid two digit number, Add the previous to previous element's value to the current element (DP[i] += DP[i-2])<br /><br />In one line : DP[i] = DP[i-1] {if valid single digit number} + DP[i-2] {if current and previous elements make a valid two digit number}<br /><br />Solution:<br /></blockquote><pre class="prettyprint"># include &lt;cstdio&gt;<br /># include &lt;cstring&gt;<br />char Input[5001] = "";<br />unsigned long long DP[5001];<br />int main()<br />{<br /> freopen ("Input.txt", "r", stdin);<br /> freopen ("Scratch.txt", "w", stdout);<br /> scanf ("%s", Input);<br /> while (strcmp(Input, "0"))<br /> {<br />  int Len = strlen (Input), Index = 1;<br />  memset (DP, 0, sizeof DP);<br />  DP[0] = 1;<br />  while (Index &lt; Len)<br />  {<br />   int temp = 0;<br />   temp = (Input[Index-1]-'0') * 10;<br />   temp += (Input[Index] -'0');<br />   if (Input[Index]-'0') DP[Index] = DP[Index-1];<br />   if (temp &lt;= 26 &amp;&amp; temp &gt; 9) DP[Index] += DP[Index-2 &lt; 0?0:Index-2];<br />   //printf ("%d\t%llu\n",Index, DP[Index]);<br />   Index++;<br />  }<br />  //printf ("%llu\t%s\n", DP[Len-1], Input);<br />  printf ("%llu\n", DP[Len-1]);<br />  scanf ("%s", Input);<br /> }<br />}<br /><br /></pre></div></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Timus - 1018 - Binary Apple Tree - Dynamic Programming]]></title>
    <link href="http://thefourtheye.in/2013/04/21/timus-1018-binary-apple-tree-dynamic/"/>
    <updated>2013-04-21T23:00:00+05:30</updated>
    <id>http://thefourtheye.in/2013/04/21/timus-1018-binary-apple-tree-dynamic</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on">Today, I saw this interesting problem. <br /><br /><a href="http://acm.timus.ru/problem.aspx?space=1&amp;num=1018">Timus - 1018 - Binary Apple Tree</a><br /><br />When I started working on this, I didnt know why do we need Dynamic Programming to solve this. My idea was pretty simple.  <blockquote>1. While reading Inputs find the total number of apples<br />2. Find all the leaf Branches (I mean branches without any branches on them)<br />3. Get the branch with the least number of apples and remove that<br />4. Goto Step 2 until N - Q - 1 times. (N is the total number of enumerated points on the tree, Q is the number of branches to keep, Always there will be N - 1 branches on the binary tree. So N - Q - 1 will give the number of branches to be removed) </blockquote>It was pretty straight forward to implement.<br /><pre class="prettyprint"># include &lt;cstdio&gt;<br /># include &lt;map&gt;<br /># include &lt;set&gt;<br /># include &lt;bitset&gt;<br />using namespace std;<br />int N, Q;<br />unsigned long long Total = 0;<br />struct Branch<br />{<br /> bool operator&lt; (const Branch &amp; branch) const<br /> {<br />  if (this-&gt;Apples == branch.Apples)<br />  {<br />   if (this-&gt;Start == branch.Start)<br />    return this-&gt;End &lt; branch.End;<br />   return this-&gt;Start&lt; branch.Start;<br />  }<br />  return this-&gt;Apples &lt; branch.Apples;<br /> }<br /> Branch (int a, int b, int c){Start = a; End = b; Apples = c;}<br /> int Start, End, Apples;<br />};<br />set &lt;Branch&gt; Edges;<br />bitset &lt;101&gt; Visited;<br />map &lt;int, map &lt;int, int&gt; &gt; Tree;<br />void FindEdges (int current, int parent)<br />{<br /> //printf ("%d\t%d\n", current, parent);<br /> if (Visited[current]) return;<br /> //printf ("%d\t%d Not Visited\n", current, parent);<br /> Visited[current] = true;<br /> map&lt;int, int&gt;::iterator it = Tree[current].begin();<br /> if (Tree[current].size() == 1)<br />  Edges.insert (Branch (parent, current, Tree[parent][current]));<br /> else<br />  for (; it != Tree[current].end(); it++)<br />   if (!Visited[it-&gt;first])<br />    FindEdges (it-&gt;first, current);<br />}<br />int main()<br />{<br /> //freopen ("Input.txt", "r", stdin);<br /> //freopen ("Scratch.txt", "w", stdout);<br /> scanf ("%d%d", &amp;N, &amp;Q);<br /> Q = N - 1 - Q;<br /> int A, B, C;<br /> for (int i = 0; i &lt; N - 1; i++)<br /> {<br />  scanf ("%d%d%d", &amp;A, &amp;B, &amp;C);<br />  Tree[A][B] = C;<br />  Tree[B][A] = C;<br />  Total += C;<br /> }<br /> for (int i = 0; i &lt; Q; i++)<br /> {<br />  Edges.clear();<br />  Visited.reset();<br />  map&lt;int, int&gt;::iterator it1 = Tree[1].begin();<br />  Visited[1] = true;<br />  for (; it1 != Tree[1].end(); it1++)<br />   FindEdges(it1-&gt;first, 1);<br />  //printf ("Edges Size : %lu\n", Edges.size());<br />  set&lt;Branch&gt;::iterator it = Edges.begin();<br />  //printf ("%d\t%d\t%d\n", it-&gt;Start, it-&gt;End, it-&gt;Apples);<br />  Total -= it-&gt;Apples;<br />  Tree[it-&gt;Start].erase (it-&gt;End);<br />  Tree[it-&gt;End].erase (it-&gt;Start);<br /> }<br /> printf ("%llu\n", Total);<br />}<br /></pre>However, this solution was failing so many times. Then I found the testcase for which this program was failing.  <pre class="prettyprint">4 1<br />1 2 1<br />1 3 2<br />2 4 3<br /><br /></pre>The above shown solution returns 1 as the result whereas the optimal result is 2. This approach is greedy approach I believe. <br />In the first iteration, it detects the branches <pre class="prettyprint">1 3 2<br />2 4 3<br /></pre>and removes the branch 1 3 2, since it has the least number of apples and in the next iteration it detects the following branch <pre class="prettyprint">2 4 3<br /></pre>since that is the only leaf branch available and it removes that, leaving us with the suboptimal solution 1. <br /><br />Here is the DP solution which can really solve this problem and this got accepted by Timus.<br /><br /><pre class="prettyprint">#include &lt;cstdio&gt;<br />#include &lt;cstring&gt;<br />#include &lt;vector&gt;<br />#include &lt;algorithm&gt;<br /><br />using namespace std;<br /><br />int N,Q, Tree[101][101], DP[101][101];<br />int solve (int current, int parent, int q)<br />{<br /> if (q &lt;= 0) return 0;<br /> int lindex = -1, rindex = -1;<br /> int &amp; result = DP[current][q];<br /> if (result != -1) return result;<br /> for (int i = 0; i &lt; 101; i++)<br />  if (Tree[current][i] != -1 &amp;&amp; i != parent) {lindex = i; break;}<br /> for (int i = (lindex == -1?0:lindex+1); i &lt; 101; i++)<br />  if (Tree[current][i] != -1 &amp;&amp; i != parent) {rindex = i; break;}<br /> //printf ("%d\t%d\t%d\t%d\t%d\n", current, parent, lindex, rindex, q);<br /> if (lindex == -1 || rindex == -1) return 0;<br /> for (int i = 0; i &lt;= q; i++)<br />  result = max (result, (i == q?0:Tree[current][lindex] + solve(lindex, current, q - i - 1))<br />   + (i == 0?0:Tree[current][rindex] + solve(rindex, current, i - 1)));<br /> //printf ("Returning %d\n", result);<br /> return result;<br />}<br />int main()<br />{<br /> //freopen ("Input.txt", "r", stdin);<br /> //freopen ("Scratch.txt", "w", stdout);<br /> scanf("%d%d",&amp;N,&amp;Q);<br /> memset (Tree, -1, sizeof Tree);<br /> memset (DP, -1, sizeof DP);<br /> for (int i = 0; i &lt; N; i++)<br />  for (int j = 0, x, y, z; j &lt; N; j++)<br />  {<br />   scanf ("%d%d%d", &amp;x, &amp;y, &amp;z);<br />   Tree [x][y] = z;<br />   Tree [y][x] = z;<br />  }<br /> printf ("%d\n", solve (1, 0, Q));<br /> return 0;<br />}<br /></pre>Please write to me if you want me to explain this program. We can do that over chat. </div></div>
]]></content>
  </entry>
  
</feed>
