<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Spoj | thefourtheye's weblog]]></title>
  <link href="http://thefourtheye.in/blog/categories/spoj/atom.xml" rel="self"/>
  <link href="http://thefourtheye.in/"/>
  <updated>2019-05-06T10:06:38+05:30</updated>
  <id>http://thefourtheye.in/</id>
  <author>
    <name><![CDATA[Sakthipriyan Vairamani (thefourtheye)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SPOJ Best Solutions for the Double Helix]]></title>
    <link href="http://thefourtheye.in/2013/06/30/spoj-best-solutions-for-double-helix/"/>
    <updated>2013-06-30T18:08:00+05:30</updated>
    <id>http://thefourtheye.in/2013/06/30/spoj-best-solutions-for-double-helix</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on">Unforgettable day. Got my solution featured, as one of the best Python solutions to "<a href="http://www.spoj.com/problems/ANARC05B/">The Double Helix</a>" problem. <br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="http://1.bp.blogspot.com/-wzk1jclGSXQ/UdAmerJssFI/AAAAAAAABYk/pb3O4uzgCmk/s1280/SPOJ+Top+20.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://1.bp.blogspot.com/-wzk1jclGSXQ/UdAmerJssFI/AAAAAAAABYk/pb3O4uzgCmk/s1280/SPOJ+Top+20.png" style="max-width: 100%; max-height: 100%;" /></a></div></div></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SPOJ - ACODE - AlphaCode]]></title>
    <link href="http://thefourtheye.in/2013/04/23/spoj-acode-alphacode/"/>
    <updated>2013-04-23T21:34:00+05:30</updated>
    <id>http://thefourtheye.in/2013/04/23/spoj-acode-alphacode</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on"><blockquote>Problem Description - <a href="http://www.spoj.com/problems/ACODE/">http://www.spoj.com/problems/ACODE/</a><br /><br />Approach :<br /><br />1) Initialize an Array of Size N with 0 and element 0 as 1<br />2) Loop through all the elements<br />3) If it is a valid single digit number, Copy the previous element's value to the current element (DP[i] = DP[i-1])<br />4) If it is a valid two digit number, Add the previous to previous element's value to the current element (DP[i] += DP[i-2])<br /><br />In one line : DP[i] = DP[i-1] {if valid single digit number} + DP[i-2] {if current and previous elements make a valid two digit number}<br /><br />Solution:<br /></blockquote><pre class="prettyprint"># include &lt;cstdio&gt;<br /># include &lt;cstring&gt;<br />char Input[5001] = "";<br />unsigned long long DP[5001];<br />int main()<br />{<br /> freopen ("Input.txt", "r", stdin);<br /> freopen ("Scratch.txt", "w", stdout);<br /> scanf ("%s", Input);<br /> while (strcmp(Input, "0"))<br /> {<br />  int Len = strlen (Input), Index = 1;<br />  memset (DP, 0, sizeof DP);<br />  DP[0] = 1;<br />  while (Index &lt; Len)<br />  {<br />   int temp = 0;<br />   temp = (Input[Index-1]-'0') * 10;<br />   temp += (Input[Index] -'0');<br />   if (Input[Index]-'0') DP[Index] = DP[Index-1];<br />   if (temp &lt;= 26 &amp;&amp; temp &gt; 9) DP[Index] += DP[Index-2 &lt; 0?0:Index-2];<br />   //printf ("%d\t%llu\n",Index, DP[Index]);<br />   Index++;<br />  }<br />  //printf ("%llu\t%s\n", DP[Len-1], Input);<br />  printf ("%llu\n", DP[Len-1]);<br />  scanf ("%s", Input);<br /> }<br />}<br /><br /></pre></div></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Next Palindrome After a 1000000 Digit Number - SPOJ - PALIN]]></title>
    <link href="http://thefourtheye.in/2012/10/21/next-palindrome-after-1000000-digit/"/>
    <updated>2012-10-21T18:38:00+05:30</updated>
    <id>http://thefourtheye.in/2012/10/21/next-palindrome-after-1000000-digit</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on">I always have afraid of the problems which require string processing, to be solved. This is one such problem. The problem description as stated in SPOJ (<a href="http://www.spoj.pl/problems/PALIN/">http://www.spoj.pl/problems/PALIN/</a>) and my solution to this problem is&nbsp;<a href="http://ideone.com/osqLhp">http://ideone.com/osqLhp</a>&nbsp;(I am sure, I can improve this code)<br /><br /><h1 style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 20px; font-weight: normal; text-align: left;"><span style="font-size: 13px; text-align: justify;">A positive integer is called a</span><span style="font-size: 13px; text-align: justify;">&nbsp;</span><i style="background-color: transparent; font-size: 13px; text-align: justify;">palindrome</i><span style="font-size: 13px; text-align: justify;">&nbsp;</span><span style="font-size: 13px; text-align: justify;">if its representation in the decimal system is the same when read from left to right and from right to left. For a given positive integer K of not more than 1000000 digits, write the value of the smallest palindrome larger than K to output. Numbers are always displayed without leading zeros.</span></h1><br /><h3 style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; text-align: center;">Input</h3><div align="justify" style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13px; text-align: justify;">The first line contains integer t, the number of test cases. Integers K are given in the next t lines.</div><h3 style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; text-align: center;">Output</h3><div align="justify" style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13px; text-align: justify;">For each K, output the smallest palindrome larger than K.</div><h3 style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; text-align: center;">Example</h3><div style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13px; text-align: justify;"><tt><b>Input:</b></tt><br />2<br />808<br />2133</div><div style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13px; text-align: justify;"><br /></div><div style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13px; text-align: justify;"><tt><b>Output:</b></tt><br />818<br />2222</div><br /><br />We know that, there is no integral data type which is as sophisticated as to&nbsp;accommodate a 1000000 digits number (a million digits in a number). So only option is to use string. And we also know what palindrome is. A number or a string of characters, is the same when expressed from left to right and right to left. For example, AMMA, MADAM, MALAYALAM, 11, 505, 797979797, ...<br /><br />Lets assume the input number as N. If we read through the problem, we are asked to find the next (greater than the number provided) palindrome which exists after the number N. As we see in the examples, 818 is the next big palindrome after 808 and 2222 is the next big palindrome after 2133. If the numbers are small, we can try brute-force approach.<br /><br /><h3 style="text-align: left;">Brute force approach:</h3><br /><ol style="text-align: left;"><li>Read the number N</li><li>Increment by 1</li><li>Check whether it is a palindrome or not</li><li>If Yes, Print the number and exit</li><li>If No, goto step 2</li></ol><div><br /></div><div>This approach is quite simple and easy to implement. But, this may not work always when we have time constraints. If the number N becomes as big as a 1000000 digit number, program with this approach would produce output after a very long time. We all want our programs to produce outputs so quickly, don't we?&nbsp;Let us look at the approach which I followed to solve this problem.</div><div><br /></div><h3 style="text-align: left;">My approach:</h3><div><ol style="text-align: left;"><li>Read the number as a string and store it in STR and the number of digits as N</li><li>Split STR into two halves STR1 and STR3, if the number of digits in STR is odd, the middle digit will be in STR2 otherwise it is empty</li><li>If the Reverse of STR1 is greater than STR3, Print STR1 + STR2 + Reverse (STR1) and exit</li><li>make all digits of STR3 as '0'</li><li>If N is even,&nbsp;</li><ol><li>increment STR1</li><li>Goto step 1 with input (Incremented STR1 + STR3)</li></ol><li>If N is odd,&nbsp;</li><ol><li>increment STR2</li><ol><li>If Incremented STR2 is 10,&nbsp;</li><ol><li>set STR2 as "0"</li><li>increment STR1</li><li>Goto step 1 with input (Incremented STR1 + STR2 + STR3)</li></ol><li>If Incremented STR2 is lesser than 10</li><ol><li>Goto step 1 with input (STR1 + STR2 + STR3)</li></ol></ol></ol></ol><div>The observation which I made after analyzing few examples is, if the second half of the number is smaller than the reverse of the first half of the number, just replacing the&nbsp;second half&nbsp;with&nbsp;the reverse of the first half produces the required output. If it is not smaller than the reverse of the first half, increment the first half and then replace the second half with the incremented first half. This is the basic idea but the above algorithm includes all the corner cases.</div></div><br /><b>My solution:</b></div><script type="text/javascript" src="http://ideone.com/api/embed.js/link/osqLhp"></script></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Infix Expression to Postfix (RPN) Expression Conversion - SPOJ - ONP]]></title>
    <link href="http://thefourtheye.in/2012/10/21/infix-expression-to-postfix-rpn/"/>
    <updated>2012-10-21T17:46:00+05:30</updated>
    <id>http://thefourtheye.in/2012/10/21/infix-expression-to-postfix-rpn</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on"><div style="text-align: justify;">This was one of our lab exercises in my Engineering first year. That was Data Structures lab. Guess what, this program was agreed as the toughest program of all the programs, by the whole class (our class strength was 63), which we were supposed to finish in that semester and the teacher had the whole program written on the blackboard and later we typed, compiled and executed on the computers. I remember the days, in which I used to memorize the program which solved the same problem for the lab exams.&nbsp;Nostalgic!!!&nbsp;Now, this took me lesser than 15 minutes to get "accepted" in SPOJ&nbsp;:)</div><div style="text-align: justify;"><br /></div><div style="text-align: left;">Here is the problem statement, as stated in SPOJ (<a href="http://www.spoj.pl/problems/ONP/" style="text-align: left;">http://www.spoj.pl/problems/ONP/</a>). My solution to the same&nbsp;<a href="http://ideone.com/wCfryC">http://ideone.com/wCfryC</a></div><div style="text-align: justify;"><br /></div><div style="text-align: justify;"></div><div align="justify" style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13px;">Transform the algebraic expression with brackets into RPN form (Reverse Polish Notation). Two-argument operators: +, -, *, /, ^ (priority from the lowest to the highest), brackets ( ). Operands: only letters: a,b,...,z. Assume that there is only one RPN form (no expressions like a*b*c).</div><h3 style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; text-align: center;">Input</h3><pre style="background-color: #f6f9e0; color: #000020; font-size: 13px; text-align: left;"><i>t</i> [the number of expressions &lt;= <b>100</b>]<br /><i>expression</i> [length &lt;= <b>400</b>]<br />[other expressions]<br /></pre><div align="left" style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 13px;">Text grouped in [ ] does not appear in the input file.</div><h3 style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; text-align: center;">Output</h3><pre style="background-color: #f6f9e0; color: #000020; font-size: 13px; text-align: left;">The <em>expression</em>s in RPN form, one per line.<br /></pre><h3 style="background-color: #f6f9e0; color: #000020; font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 15px; text-align: center;">Example</h3><pre style="background-color: #f6f9e0; color: #000020; font-size: 13px; text-align: left;">Input:<br />3<br />(a+(b*c))<br />((a+b)*(z+x))<br />((a+t)*((b+(a+c))^(c+d)))<br /><br />Output:<br />abc*+<br />ab+zx+*<br />at+bac++cd+^*</pre></div><script type="text/javascript" src="http://ideone.com/api/embed.js/link/wCfryC"></script></div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Prime Numbers and Basic Primality Tests - SPOJ - Prime1]]></title>
    <link href="http://thefourtheye.in/2012/10/09/prime-numbers-and-basic-primality-tests/"/>
    <updated>2012-10-09T16:40:00+05:30</updated>
    <id>http://thefourtheye.in/2012/10/09/prime-numbers-and-basic-primality-tests</id>
    <content type="html"><![CDATA[<div class="post">
<div dir="ltr" style="text-align: left;" trbidi="on"><b>Prime numbers</b> are the numbers which get divided properly (leaving remainder as 0) only by 1 and the same number.<br /><br />The same way, numbers which get divided by 1, the same number and other numbers are called <b>composite numbers</b>.<br /><br />Current state of the art security infrastructures rely on security schemes such as RSA and DSA. They both, in turn, rely heavily on Prime numbers. So prime numbers are so important in the digital world's security. Lets see few of the algorithms to determine whether the given number is a Prime number or not.<br /><br /><h3 style="text-align: left;">Basic Tests for Primality</h3><div>Lets say, we want to find whether the numbers 101 and 100 are prime numbers are not.</div><h4 style="text-align: left;">Approach 1</h4><div><br /></div><div>This is the very basic approach and very easy to implement.</div><div><br /></div><div style="text-align: left;"><ul style="text-align: left;"><li>Read the number n</li><li>Loop with i from 2 till n/2 (if it doesn't divide properly, round off is needed)</li><li>if i divides n with out leaving any remainder (remainder is 0)&nbsp;then return false</li><li>End Loop</li><li>return true</li></ul><div><br /></div><div>The idea here is to check whether each and every number from 2 till half of that number [2, n/2] divides the number or not. If any of them divides the number without leaving any remainder, we can declare that the number is NOT a prime number. If no number in that range divides properly, the number is called a Prime number. We check only till n/2, because 2 * n/2 would be n, there would be no number greater than n/2 would divide n properly. In the worst case, It needs n/2 iterations to confirm whether the number is prime or not. In our case, for 101,&nbsp;it is 50.</div><div><br /></div><div><h4>Approach 2</h4></div><div><br /></div><div>The simplicity of this algorithm would tempt us to use this always. Lets see, if we can improve this. If we observe closely, if the number n is odd, we don't even have to try any of the even numbers. This would reduce the number of iterations needed by half.</div><div><br /></div><div><ul><li>Read the number n</li><li>if n is even return false</li><li>Loop with i from 3 till n/2, increment i by 2</li><li>if i divides n with out leaving any remainder (remainder is 0)&nbsp;then return false</li><li>End Loop</li><li>return true</li></ul><div><br /></div></div><div>As we can clearly see, if n is even it can not be a prime number, since if a number is even it is divisible by 2. So we check only the odd numbers starting from 3 till n/2 and we are skipping all the even number &nbsp;by incrementing the loop's index variable by 2 every time. So the loop would be run for the values 3,5,7,9, 11... Now if we look at the performance of this approach, we just need n/4 iterations to find whether the number is a prime number or not. In our case, for 101, it is 25.</div><div><br /></div><h4 style="text-align: left;">Approach 3</h4><div><br /></div><div>Lets see, if we can reduce it further from n/4. Lets write down the combinations which would yield 100. {2, 50}, {4, 25}, {5, 20} and {10, 10}. Lets try 256. {2, 128}, {4, 64}, {8, 32}, {16, 16}. In both the cases, atleast one of the numbers is always lesser than equal to the square root of the actual number. (I, honestly, don't know how to prove this, but this observation works always). So, instead of looping till n/2 we are going to limit the loop at square root of the number. Combining the observation we made in approach 2, presenting approach 3.</div><div><br /></div><div><ul><li>Read the number n</li><li>if n is even return false</li><li>Loop with i from 3 till sqrt (n), increment i by 2</li><li>if i divides n with out leaving any remainder (remainder is 0)&nbsp;then return false</li><li>End Loop</li><li>return true</li></ul><div><br /></div><div>In our case, we see a tremendous hike in performance,&nbsp;for the value 101,&nbsp;in the worst case we might have to do only 4 checks.</div></div><div><br /></div><div><h4>Approach 4</h4></div><div><br /></div><div>We have already had good performance with approach 3. Lets see if we still can improve it. Lets list the four values with which we may need to divide 101 to determine whether it is prime or not. The values are {2, 3, 5, 7, 9}. We have 2 as well here, since we check whether the input is even or not and 11 is not included because sqrt (101) would be rounded off to 10. The odd item in the list is 9, since we are checking against all the odd number between 2 and sqrt(n). We all know that, any given composite (non-prime) number can be expressed in terms of its prime factors. So we can try and divide the number only with the prime numbers within the range [2, sqrt(n)]. <b>Note:</b> This approach works only when we have a predetermined list of prime numbers. If we don't have that its better to stick to approach 3 or have a look at approach 5 below.</div><div><br /></div><div><h4>Approach 5</h4></div><div><br /></div><div>Lets observe the list the prime numbers a bit.</div><div><span style="font-family: inherit;"><br /></span></div><div><span style="font-family: inherit;">{<span style="background-color: white; line-height: 19.200000762939453px;">2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101...}</span></span></div><div><span style="font-family: inherit;"><span style="background-color: white; line-height: 19.200000762939453px;"><br /></span></span></div><div><span style="font-family: inherit;"><span style="background-color: white; line-height: 19.200000762939453px;">Lets rewrite them like this</span></span></div><div><span style="font-family: inherit;"><span style="background-color: white; line-height: 19.200000762939453px;"><br /></span></span></div><div>{<span style="background-color: white; line-height: 19.200000762939453px;">2, 3, 6*1-1,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*1+1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*2-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*2+1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*3-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*3+1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*4-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*5-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*5+1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*6+1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*7-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*7+1,</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*8-1</span><span style="background-color: white; line-height: 19.200000762939453px;">&nbsp;&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*9-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*10-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*10+1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*11+1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*12-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*12+1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*13-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*14-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*15-1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*16+1</span><span style="background-color: white; line-height: 19.200000762939453px;">,&nbsp;</span><span style="background-color: white; line-height: 19.200000762939453px;">6*17-1</span><span style="background-color: white; line-height: 19.200000762939453px;">...}</span></div><div><span style="background-color: white; line-height: 19.200000762939453px;"><br /></span></div><div><span style="background-color: white; line-height: 19.200000762939453px;">Basically, the prime numbers are of the form <span style="font-family: inherit;">(6*x)</span></span><span style="background-color: white; color: #222222; line-height: 16px;"><span style="font-family: inherit;">Â±1 (though few of them may not be prime numbers). This reduces the possible values to be looked at, to a greater extent.&nbsp;</span></span></div><div><span style="background-color: white; color: #222222; line-height: 16px;"><span style="font-family: inherit;"><br /></span></span></div><div><ul><li>Read the number n</li><li>if n is even return false</li><li>if 3 divides n properly return false</li><li>Loop with i from 1 till&nbsp;(6 * i) -1 &gt;&nbsp;sqrt&nbsp;(n), increment i by 1 every time</li><li>if&nbsp;(6 * i) -1 or&nbsp;(6 * i) + 1&nbsp;divides n with out leaving any remainder (remainder is 0)&nbsp;then return false</li><li>End Loop</li><li>return true</li></ul><div><br /></div><div>This method would be the fastest of all the methods discussed, I believe.</div></div><div><br /></div><div>Based on the ideas discussed above, I managed to solved the SPOJ's PRIME1 problem. The problem description can be found here&nbsp;<a href="http://www.spoj.pl/problems/PRIME1/" target="_blank">http://www.spoj.pl/problems/PRIME1/</a></div><div><br /></div><div><b>Spoiler alert:</b> This&nbsp;<a href="http://ideone.com/4n9kB">http://ideone.com/4n9kB</a>&nbsp;has my solution to the above mentioned PRIME1 problem.</div></div></div><script type="text/javascript" src="http://ideone.com/api/embed.js/link/4n9kB"></script></div>
]]></content>
  </entry>
  
</feed>
